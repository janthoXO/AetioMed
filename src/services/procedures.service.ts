import {
  getCreativeLLM,
  getDeterministicLLM,
  handleLangchainError,
  parseStructuredResponseAgent,
} from "@/ai/llm.js";
import type { Case } from "@/domain-models/Case.js";
import type { Diagnosis } from "@/domain-models/Diagnosis.js";
import type { Inconsistency } from "@/domain-models/Inconsistency.js";
import {
  PredefinedProcedures,
  ProcedureWithRelevanceArrayJsonExampleString,
  ProcedureWithRelevanceSchema,
  type Procedure,
  type ProcedureWithRelevance,
} from "@/domain-models/Procedure.js";
import type { Symptom } from "@/domain-models/Symptom.js";
import { retry } from "@/utils/retry.js";
import Fuse from "fuse.js";
import {
  createAgent,
  HumanMessage,
  providerStrategy,
  SystemMessage,
} from "langchain";
import path from "node:path";
import YAML from "yaml";
import fs from "fs";
import z from "zod";
import type { Language } from "@/domain-models/Language.js";
import { proceduresQueryTool } from "@/ai/tools/procedures.tool.js";

export async function generateProceduresCoT(
  diagnosis: Diagnosis,
  symptoms: Symptom[],
  relatedCase?: Case,
  userInstructions?: string
): Promise<string> {
  const systemPrompt = `You are a doctor whos patient has these symptoms: 
${symptoms.map((s) => s.name).join(", ")}
Generate a step by step reasoning process which procedures should be performed.
Return the steps as a list of steps in markdown format.
${
  relatedCase
    ? `The patient case has the following properties which might be relevant for the procedures generation:
  ${JSON.stringify(relatedCase)}`
    : ""
}`;

  const userPrompt = [
    `Provided Diagnosis: ${diagnosis.name} ${diagnosis.icd ?? ""}`,
    userInstructions
      ? `Additional provided instructions: ${userInstructions}`
      : "",
  ]
    .filter((s) => s.length > 0)
    .join("\n");

  console.debug(
    `[GenerateProceduresCoT] Prompt:\n${systemPrompt}\n${userPrompt}`
  );

  try {
    const stepsString: string = await retry(
      async () => {
        const text = await getDeterministicLLM({ outputFormat: "text" })
          .invoke([
            new SystemMessage(systemPrompt),
            new HumanMessage(userPrompt),
          ])
          .catch((error) => {
            handleLangchainError(error);
          });
        console.debug("[GenerateProceduresCoT] LLM raw Response:\n", text);

        return text.text;
      },
      2,
      0
    );

    return stepsString;
  } catch (error) {
    console.error(`[GenerateProceduresCoT] Error:`, error);
    throw error;
  }
}

export async function generateProceduresOneShot(
  diagnosis: Diagnosis, // provided by the user
  symptoms: Symptom[], // generate by a chain step
  relatedCase?: Case, // generated by a previous chain step
  cot?: string, // generated by a previous chain step
  userInstructions?: string, // provided by the user
  inconsistencies?: Inconsistency[] // generated by a previous chain step
): Promise<ProcedureWithRelevance[]> {
  const { procedures: previousProcedures, ...caseWithoutProcedures } =
    relatedCase ?? {};

  const systemPrompt = `You are a doctor whos patient has these symptoms: 
${symptoms.map((s) => s.name).join(", ")}
Generate a list of procedures that should be performed.
${cot ? `Think step by step:\n${cot}` : ""}
${
  Object.keys(caseWithoutProcedures).length > 0
    ? `The patient case has the following properties which might be relevant for the procedures generation:
  ${JSON.stringify(caseWithoutProcedures)}`
    : ""
}
${
  previousProcedures
    ? `Try to fix the inconsistencies from the previous procedures generated:\n${JSON.stringify({ procedures: previousProcedures })}
with inconsistencies:
${inconsistencies
  ?.map((i, idx) => {
    return `${idx + 1}. severity ${i.severity}: ${i.description}
suggested fix: ${i.suggestion}`;
  })
  .join("\n")}`
    : ``
}

Use the "query_procedures" tool to search for procedures. ONLY use the specified procedures from there unless it tells you otherwise.
Return your response in JSON
${`{ "procedures": ${ProcedureWithRelevanceArrayJsonExampleString()} }`}

Requirements:
- Be medically accurate and realistic
- Use standard medical terminology
- Return ONLY the JSON object, no additional text`;

  const userPrompt = [
    `Provided Diagnosis: ${diagnosis.name} ${diagnosis.icd ?? ""}`,
    userInstructions
      ? `Additional provided instructions: ${userInstructions}`
      : "",
  ]
    .filter((s) => s.length > 0)
    .join("\n");

  console.debug(
    `[GenerateProceduresOneShot] Prompt:\n${systemPrompt}\n${userPrompt}`
  );

  // Initialize cases to empty in case of failure
  try {
    const ProcedureSchemaWrapper = z.object({
      procedures: z
        .array(ProcedureWithRelevanceSchema)
        .describe("Generated procedures"),
    });

    const procedures: ProcedureWithRelevance[] = await retry(
      async () => {
        const result = await createAgent({
          model: getCreativeLLM(),
          tools: [proceduresQueryTool],
          systemPrompt: systemPrompt,
          responseFormat: providerStrategy(ProcedureSchemaWrapper),
        })
          .invoke({ messages: [new HumanMessage(userPrompt)] })
          .catch((error) => {
            handleLangchainError(error);
          });

        console.debug(
          "[GenerateProceduresOneShot] LLM raw Response:\ncontent:\n",
          result.messages[result.messages.length - 1]?.content,
          "\nstructured response:\n",
          result.structuredResponse
        );

        return parseStructuredResponseAgent(result, ProcedureSchemaWrapper)
          .procedures;
      },
      2,
      0
    );

    return procedures;
  } catch (error) {
    console.error(`[GenerateProceduresOneShot] Error:`, error);
    throw error;
  }
}

const fuse = PredefinedProcedures
  ? new Fuse(PredefinedProcedures, {
      keys: ["name", "description"],
      includeScore: true,
      shouldSort: true,
      threshold: 0.4,
    })
  : null;

export class NoPredefinedProceduresError extends Error {
  constructor(message: string = "No predefined procedures available") {
    super(message);
  }
}

export function searchForProcedures(query: string): Procedure[] {
  if (!fuse) {
    throw new NoPredefinedProceduresError();
  }

  const results = fuse.search(query);
  return results.map((result) => result.item);
}

const LanguageProcedureTranslationSchema = z.partialRecord(
  z.enum(["English", "German"]),
  z.record(z.string(), z.string())
);

type LanguageProcedureTranslationMapping = z.infer<
  typeof LanguageProcedureTranslationSchema
>;

function preloadProcedureTranslations(): LanguageProcedureTranslationMapping {
  const filepath = path.resolve(
    import.meta.dirname,
    "../data/proceduresTranslations.yml"
  );

  const translationsObject = YAML.parse(fs.readFileSync(filepath, "utf-8"));

  const parseResult =
    LanguageProcedureTranslationSchema.safeParse(translationsObject);
  if (!parseResult.success) {
    console.error(
      "Error parsing procedure translations YAML:",
      parseResult.error
    );
    return {}; // Return empty object on parsing failure
  }

  console.info(
    "[Procedures] Loaded procedure translations from YAML:",
    parseResult.data
  );
  return parseResult.data;
}

/**
 * Mapping of procedure translations from English to other languages
 *
 * e.g. { German: { "Blood Test": "Bluttest", ... } }
 */
const ProcedureTranslations: LanguageProcedureTranslationMapping =
  preloadProcedureTranslations();

/**
 * Get the translation of a procedure from English to the target language
 * @param category
 * @param language
 * @returns
 */
function getProcedureTranslationFromEnglish(
  procedure: Procedure,
  language: Language
): Procedure | undefined {
  const translatedName = ProcedureTranslations[language]?.[procedure.name];
  if (translatedName) {
    return { name: translatedName };
  }

  return undefined;
}

async function generateProceduresFromEnglish(
  procedures: Procedure[],
  language: Language
): Promise<(Procedure | undefined)[]> {
  const systemPrompt = `Translate the provided procedures from English to a target language:
  
Return the procedures mapped to their translated part in a JSON
{
  "provided procedure1": "translated procedure1",
  "provided procedure2": "translated procedure2",
  ...
}
ONLY return the JSON object, no additional text.`;

  const userPrompt = `Target language: ${language}
Procedures to translate:
${procedures.map((p) => p.name.toLowerCase()).join("\n")}`;

  console.debug(
    `[Procedures Service] Generating procedure translations with prompt: 
  ${systemPrompt}
  ${userPrompt}`
  );

  const prompt = [
    { role: "system", content: systemPrompt },
    { role: "user", content: userPrompt },
  ];

  const parsed = await retry(
    async () => {
      const response = await getDeterministicLLM().invoke(prompt);

      console.debug(
        "[Procedures Service] Generated procedure translations:",
        response.text
      );

      const responseSchema = z.record(z.string(), z.string());
      return responseSchema.parse(JSON.parse(response.text));
    },
    2,
    0
  );

  // Filter only the requested procedures
  const sortedTranslation: (Procedure | undefined)[] = procedures.map(
    () => undefined
  );
  for (const [original, translated] of Object.entries(parsed)) {
    const index = procedures
      .map((p) => p.name.toLowerCase())
      .indexOf(original.toLowerCase());
    if (index === -1) {
      continue; // keep the original procedure if no translation was provided
      // throw new Error(
      //   `The procedure "${original}" was not in the list of procedures to translate.`
      // );
    }
    sortedTranslation[index] = { name: translated };
  }

  return sortedTranslation;
}

export async function translateProceduresFromEnglish(
  procedures: Procedure[],
  language: Language
): Promise<Procedure[]> {
  const translations: Procedure[] = [];
  const failedTranslations: { index: number; procedure: Procedure }[] = [];
  for (let i = 0; i < procedures.length; i++) {
    const englishProcedure = getProcedureTranslationFromEnglish(
      procedures[i]!,
      language
    );

    if (englishProcedure) {
      translations[i] = englishProcedure;
    } else {
      failedTranslations.push({ index: i, procedure: procedures[i]! });
    }
  }

  if (failedTranslations.length > 0) {
    const englishProcedures = await generateProceduresFromEnglish(
      failedTranslations.map((t) => t.procedure),
      language
    );

    for (const { index, procedure } of failedTranslations) {
      // add to translations
      translations[index] = englishProcedures[index] ?? procedure;

      // save the translation to the memory cache for future use (only if translation successful)
      if (englishProcedures[index]) {
        if (!ProcedureTranslations[language]) {
          ProcedureTranslations[language] = {};
        }
        ProcedureTranslations[language][englishProcedures[index].name] =
          procedure.name;
      }
    }
  }

  return translations;
}
