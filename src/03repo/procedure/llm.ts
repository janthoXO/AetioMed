import {
  getCreativeLLM,
  getDeterministicLLM,
  handleLangchainError,
  parseStructuredResponseAgent,
} from "@/utils/llm.js";
import type { Case } from "@/02domain-models/Case.js";
import type { Diagnosis } from "@/02domain-models/Diagnosis.js";
import type { Inconsistency } from "@/02domain-models/Inconsistency.js";
import {
  ProcedureWithRelevanceArrayJsonExampleString,
  ProcedureWithRelevanceSchema,
  type ProcedureWithRelevance,
} from "@/02domain-models/Procedure.js";
import type { Symptom } from "@/02domain-models/Symptom.js";
import { retry } from "@/utils/retry.js";
import {
  createAgent,
  HumanMessage,
  providerStrategy,
  SystemMessage,
} from "langchain";
import z from "zod";
import { proceduresQueryTool } from "@/tools/procedures.tool.js";

export async function generateProceduresCoT(
  diagnosis: Diagnosis,
  symptoms: Symptom[],
  relatedCase?: Case,
  userInstructions?: string
): Promise<string> {
  const systemPrompt = `You are a doctor whos patient has these symptoms: 
${symptoms.map((s) => s.name).join(", ")}
Generate a step by step reasoning process which procedures should be performed.
Return the steps as a list of steps in markdown format.
${
  relatedCase
    ? `The patient case has the following properties which might be relevant for the procedures generation:
  ${JSON.stringify(relatedCase)}`
    : ""
}`;

  const userPrompt = [
    `Provided Diagnosis: ${diagnosis.name} ${diagnosis.icd ?? ""}`,
    userInstructions
      ? `Additional provided instructions: ${userInstructions}`
      : "",
  ]
    .filter((s) => s.length > 0)
    .join("\n");

  console.debug(
    `[GenerateProceduresCoT] Prompt:\n${systemPrompt}\n${userPrompt}`
  );

  try {
    const stepsString: string = await retry(
      async () => {
        const text = await getDeterministicLLM({ outputFormat: "text" })
          .invoke([
            new SystemMessage(systemPrompt),
            new HumanMessage(userPrompt),
          ])
          .catch((error) => {
            handleLangchainError(error);
          });
        console.debug("[GenerateProceduresCoT] LLM raw Response:\n", text);

        return text.text;
      },
      2,
      0
    );

    return stepsString;
  } catch (error) {
    console.error(`[GenerateProceduresCoT] Error:`, error);
    throw error;
  }
}

export async function generateProceduresOneShot(
  diagnosis: Diagnosis, // provided by the user
  symptoms: Symptom[], // generate by a chain step
  relatedCase?: Case, // generated by a previous chain step
  cot?: string, // generated by a previous chain step
  userInstructions?: string, // provided by the user
  inconsistencies?: Inconsistency[] // generated by a previous chain step
): Promise<ProcedureWithRelevance[]> {
  const { procedures: previousProcedures, ...caseWithoutProcedures } =
    relatedCase ?? {};

  const systemPrompt = `You are a doctor whos patient has these symptoms: 
${symptoms.map((s) => s.name).join(", ")}
Generate a list of procedures that should be performed.
${cot ? `Think step by step:\n${cot}` : ""}
${
  Object.keys(caseWithoutProcedures).length > 0
    ? `The patient case has the following properties which might be relevant for the procedures generation:
  ${JSON.stringify(caseWithoutProcedures)}`
    : ""
}
${
  previousProcedures
    ? `Try to fix the inconsistencies from the previous procedures generated:\n${JSON.stringify({ procedures: previousProcedures })}
with inconsistencies:
${inconsistencies
  ?.map((i, idx) => {
    return `${idx + 1}. severity ${i.severity}: ${i.description}
suggested fix: ${i.suggestion}`;
  })
  .join("\n")}`
    : ``
}

Follow this exact workflow:
1. First, reason about which procedures are medically appropriate for this diagnosis and symptoms. List the procedures you think are relevant.
2. For EACH procedure you identified, call the "query_procedures" tool to check whether it exists and to get the exact name. Use short, general medical terms as your search query (e.g. "blood test", "MRI", "ECG").
3. ONLY include procedures whose names were returned by the tool. Do NOT invent procedure names or use your own wording â€” use the exact names from the tool results.
4. If the tool says no predefined procedures are available, generate procedures yourself using standard medical terminology.

Return your response in JSON
${`{ "procedures": ${ProcedureWithRelevanceArrayJsonExampleString()} }`}

Requirements:
- Be medically accurate and realistic
- Use standard medical terminology
- The procedure "name" field MUST exactly match a name returned by the "query_procedures" tool
- Return ONLY the JSON object, no additional text`;

  const userPrompt = [
    `Provided Diagnosis: ${diagnosis.name} ${diagnosis.icd ?? ""}`,
    userInstructions
      ? `Additional provided instructions: ${userInstructions}`
      : "",
  ]
    .filter((s) => s.length > 0)
    .join("\n");

  console.debug(
    `[GenerateProceduresOneShot] Prompt:\n${systemPrompt}\n${userPrompt}`
  );

  // Initialize cases to empty in case of failure
  try {
    const ProcedureSchemaWrapper = z.object({
      procedures: z
        .array(ProcedureWithRelevanceSchema)
        .describe("Generated procedures"),
    });

    const procedures: ProcedureWithRelevance[] = await retry(
      async () => {
        const result = await createAgent({
          model: getCreativeLLM(),
          tools: [proceduresQueryTool],
          systemPrompt: systemPrompt,
          responseFormat: providerStrategy(ProcedureSchemaWrapper),
        })
          .invoke({ messages: [new HumanMessage(userPrompt)] })
          .catch((error) => {
            handleLangchainError(error);
          });

        console.debug(
          "[GenerateProceduresOneShot] LLM raw Response:\ncontent:\n",
          result.messages[result.messages.length - 1]?.content,
          "\nstructured response:\n",
          result.structuredResponse
        );

        return parseStructuredResponseAgent(result, ProcedureSchemaWrapper)
          .procedures;
      },
      2,
      0
    );

    return procedures;
  } catch (error) {
    console.error(`[GenerateProceduresOneShot] Error:`, error);
    throw error;
  }
}
